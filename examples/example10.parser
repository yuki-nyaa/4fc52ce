
/* 
    This example show include multiple buffer files
    and custom error message with info about location
    from lexer and parser. 
*/

/* Compile:
 
    Linux   :   bison -d -y flexexample10.parser 
                reflex --flex --bison-locations --bison-bridge --header-file=lexer.hpp example10.lexer -o lexer.cpp
                g++ ...
                
    Windows :   win_bison -d -y example10.parser -o parser.cpp
                reflex --flex --bison-locations --bison-bridge --header-file=lexer.hpp example10.lexer -o lexer.cpp
                cl /EHsc  /Feexample10.exe *.cpp   /I ..\include\ /link reflex.lib                
*/

/* Example http://dinosaur.compilertools.net/flex/flex_12.html */
/* this example can not be compiled */
/* this is a work aorund workaround */

%{
#include <string>
#include <stack>
#include <stdio.h>
#include <stdlib.h>

#include "lexer.hpp"  /* Generated by reflex: scanner_t, yyscan_t, yylex_init, yylex_destroy */

extern int  yylex   (YYSTYPE*           , YYLTYPE*  , yyscan_t      );
void        yyerror (YYLTYPE*           , yyscan_t  , const char*   );
void        yyerror (yyscan_t scanner   , const char *msg           );

/* Pass the parameter 'scanner' to yyparse through to yylex. */
#define YYPARSE_PARAM scanner
#define YYLEX_PARAM   scanner

std::stack<yyscanner_t*> buffer ;
std::stack<const char*>  bufferFileName ;

%}

%locations
%pure-parser
%lex-param { void *scanner }
%parse-param { void *scanner }



%union {
    int   num;
    char *str;
    void* obj ;     // generic object from cpp 
}

%token <str> STRING
%token <num> NUMBER
%token INCLUDE
%token FINE
%token ERROR

%%

assignments : assignment
            | assignment assignments
            ;
assignment
: 
    STRING '=' NUMBER ';' 
    { 
        printf  ("(setf %s %d)\n", $1, $3);
    }
|
    INCLUDE    
    {
        printf  ("#include#\n");
        
        buffer.push ( static_cast<yyscanner_t*>(scanner) ) ;
        
        static_cast<yyscanner_t*>(scanner)->matcher().flush();
        
        yyscanner_t scannerInclude;
        
        FILE* fi=fopen( "example10b.test", "r" );
        bufferFileName.push ("example10b.test")  ;
        
        scannerInclude.in(fi);

        buffer.push ( &scannerInclude ) ; 
        
        yyparse ( &scannerInclude ) ;
        
    }
|
    FINE 
    { 
        printf  ("#eof#\n");

        static_cast<yyscanner_t*>(buffer.top())->matcher().flush();
                
        buffer.pop() ;
        bufferFileName.pop() ;
        
        yyparse ( buffer.top() ) ;
    }
|
    ERROR
    {
        yyerror ( (void*)buffer.top(),"error parser" ) ;
    }        
;

%%

int main(void)
{
    // new way in C++ using reflex-generated yyscanner_t
    yyscanner_t scanner;
    
    // fopen file 
    FILE* fi = fopen ( "example10a.test" , "r" ) ;
    bufferFileName.push ("example10a.test")  ;
    scanner.in(fi)  ;

    // scanner is passed on to yylex()
    yyparse(&scanner);	
  
  return 0;
}
void yyerror(YYLTYPE *yylloc, yyscan_t scanner, const char *msg)
{
  (void)scanner; // appease -Wall -Werror
  fprintf(stderr, "%s at %d,%d\n", msg, yylloc->first_line, yylloc->first_column);
}
void yyerror(yyscan_t scanner, const char *msg)
{
    (void)scanner; // appease -Wall -Werror
    int row = static_cast<yyscanner_t*>(scanner)->matcher().lineno() ;
    int col = static_cast<yyscanner_t*>(scanner)->matcher().columno() + 1 ; 
    fprintf(stderr, "FILE : %s error : %s at %d,%d\n", bufferFileName.top(),msg, row,col  );
    //exit(-1);
}

