// Mini C scanner by Robert van Engelen
// A simple one-pass, syntax-directed translation of mini C to JVM bytecode
// Requires minic.l, minic.y, minic.hpp

%top{
  #include "parser.hpp"   // generated by bison from minic.y
  #include "location.hpp" // generated by bison %locations
}

// lexer syntax: enable free-space mode regular expressions for clarity
%option freespace

// lexer optimization: generate fast scanner in direct code
%option fast

// lexer class: yy::Scanner
%option namespace=yy
%option lexer=Scanner

// lexer output files
%option outfile=scanner.cpp
%option header-file=scanner.hpp

// lexer errors: throw an exception in the scanner's default rule
%option exception="yy::Parser::syntax_error(location(), \"Unknown token.\")"

// parser integration: output code for the bison complete with locations parser
%option bison-complete
%option bison-locations
%option bison-cc-namespace=yy
%option bison-cc-parser=Parser

// Scanner class
%class{

 public:

  // lookup a symbol in the "symbol table"
  ID symbol(const char *str)
  {
    return &*symbols.insert(str).first;
  }

 private:

  struct Keyword
  {
    const char *name;
    int         token;
  };

  // translate keyword to token or 0
  int keyword_token(const char *str)
  {
    static const Keyword keywords[] =
    {
      { "break",    Parser::token::TOKEN_BREAK },
      { "case",     Parser::token::TOKEN_CASE },
      { "continue", Parser::token::TOKEN_CONTINUE },
      { "default",  Parser::token::TOKEN_DEFAULT },
      { "do",       Parser::token::TOKEN_DO },
      { "else",     Parser::token::TOKEN_ELSE },
      { "false",    Parser::token::TOKEN_FALSE },
      { "float",    Parser::token::TOKEN_FLOAT },
      { "for",      Parser::token::TOKEN_FOR },
      { "if",       Parser::token::TOKEN_IF },
      { "int",      Parser::token::TOKEN_INT },
      { "main",     Parser::token::TOKEN_MAIN },
      { "print",    Parser::token::TOKEN_PRINT },
      { "return",   Parser::token::TOKEN_RETURN },
      { "string",   Parser::token::TOKEN_STRING },
      { "switch",   Parser::token::TOKEN_SWITCH },
      { "true",     Parser::token::TOKEN_TRUE },
      { "void",     Parser::token::TOKEN_VOID },
      { "while",    Parser::token::TOKEN_WHILE },
      { NULL,       0 }
    };

    for (const Keyword *keyword = keywords; keyword->name != NULL; ++keyword)
      if (strcmp(keyword->name, str) == 0)
        return keyword->token;

    return 0;
  }

  // lookup matched text() matching an {identifier}
  ID symbol()
  {
    return symbol(text());
  }

  // lookup matched text() matching a quoted {string}
  CS string()
  {
    return symbols.insert(translate_escapes()).first->c_str();
  }

  // translate \a, \b, \t, \n, \v, \f, \r, \\, and \" in matched text() matching {string}
  std::string translate_escapes()
  {
    std::string t;
    const char *s = matcher().begin() + 1;
    const char *e = matcher().end() - 1;
    while (s < e)
    {
      if (*s == '\\')
      {
        ++s;
        static const char *escapes = "abtnvfr";
        const char *esc = strchr(escapes, *s);
        if (esc != NULL)
          t.push_back(esc - escapes + '\a');
        else
          t.push_back(*s);
      }
      else
      {
        t.push_back(*s);
      }
      ++s;
    }
    return t;
  }

  // return token of matched text() matching {identifier}
  Parser::symbol_type ID()
  {
    int token = keyword_token(text());
    return token ? Parser::symbol_type(token, location()) : Parser::make_ID(symbol(), location());
  }

  // return token of matched text() matching {integer}
  Parser::symbol_type U8()
  {
    return Parser::make_U8(strtoul(text(), NULL, 10), location());
  }

  // return token of matched text() matching {float}
  Parser::symbol_type FP()
  {
    return Parser::make_F8(strtod(text(), NULL), location());
  }

  // return token of matched text() matching {character}
  Parser::symbol_type CH()
  {
    return Parser::make_U8(translate_escapes()[0], location());
  }

  // return token of matched text() matching {string}
  Parser::symbol_type CS()
  {
    return Parser::make_CS(string(), location());
  }

  // a symbol table
  std::set<std::string> symbols;

}

digit                           [0-9]
alpha                           [a-zA-Z_]
identifier                      {alpha} ( {alpha} | {digit} )*
integer                         {digit}+ | 0 [xX] [0-9a-fA-F]+
exp     	                [eE] [-+]? {digit}+
float                           {digit}+ \. {digit}* {exp}?
character                       \' ( \\. | [^\\'] )* \'
string                          \" ( \\. | [^\\"] )* \"

%%

[[:space:]]+                    // skip white space
"//".*                          // ignore inline comment
"/*"(.|\n)*?"*/"                // ignore multi-line comment using a lazy regex pattern
{identifier}                    { return ID(); }
{integer}                       { return U8(); }
{float}                         { return FP(); }
{character}                     { return CH(); }
{string}                        { return CS(); }
"+="                            { return Parser::symbol_type(Parser::token::TOKEN_PA, location()); }
"-="                            { return Parser::symbol_type(Parser::token::TOKEN_NA, location()); }
"*="                            { return Parser::symbol_type(Parser::token::TOKEN_TA, location()); }
"/="                            { return Parser::symbol_type(Parser::token::TOKEN_DA, location()); }
"%="                            { return Parser::symbol_type(Parser::token::TOKEN_MA, location()); }
"&="                            { return Parser::symbol_type(Parser::token::TOKEN_AA, location()); }
"^="                            { return Parser::symbol_type(Parser::token::TOKEN_XA, location()); }
"|="                            { return Parser::symbol_type(Parser::token::TOKEN_OA, location()); }
"<<="                           { return Parser::symbol_type(Parser::token::TOKEN_LA, location()); }
">>="                           { return Parser::symbol_type(Parser::token::TOKEN_RA, location()); }
"||"                            { return Parser::symbol_type(Parser::token::TOKEN_OR, location()); }
"&&"                            { return Parser::symbol_type(Parser::token::TOKEN_AN, location()); }
"=="                            { return Parser::symbol_type(Parser::token::TOKEN_EQ, location()); }
"!="                            { return Parser::symbol_type(Parser::token::TOKEN_NE, location()); }
"<="                            { return Parser::symbol_type(Parser::token::TOKEN_LE, location()); }
">="                            { return Parser::symbol_type(Parser::token::TOKEN_GE, location()); }
"<<"                            { return Parser::symbol_type(Parser::token::TOKEN_LS, location()); }
">>"                            { return Parser::symbol_type(Parser::token::TOKEN_RS, location()); }
"++"                            { return Parser::symbol_type(Parser::token::TOKEN_PP, location()); }
"--"                            { return Parser::symbol_type(Parser::token::TOKEN_NN, location()); }
"->"                            { return Parser::symbol_type(Parser::token::TOKEN_AR, location()); }
[!#$%&()*+,\-./:;<=>?\[\]^{|}~] { return Parser::symbol_type(chr(), location()); }
<<EOF>>                         { return Parser::make_EOF(location()); }

%%
